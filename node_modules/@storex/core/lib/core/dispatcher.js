"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class Dispatcher {
    constructor({ events, dependencies } = { events: [], dependencies: [] }) {
        this._is_async = false;
        this._waited_to_update_events = new Set();
        this._waited_to_update_funcs = new Set();
        this._dispatch_count = 0;
        this._eventsRegisterFunc = {
            onChange: new Set()
        };
        this.dispatchOnce = (func) => __awaiter(this, void 0, void 0, function* () {
            this._dispatch_count++;
            try {
                const r = func();
                if (r instanceof Promise) {
                    yield r;
                }
                console.log("dic once");
                this._dispatch_count--;
                this.dispatch();
            }
            catch (err) {
                this._dispatch_count--;
                throw err;
            }
        });
        this._sentOnChange = () => this;
        this.register = (func, eventNames) => {
            if (eventNames && eventNames.length) {
                eventNames.forEach(eventName => {
                    if (!this._eventsRegisterFunc[eventName]) {
                        this._eventsRegisterFunc[eventName] = new Set();
                    }
                    this._eventsRegisterFunc[eventName].add(func);
                });
            }
            else {
                this._eventsRegisterFunc.onChange.add(func);
            }
        };
        this.unregisterFromAll = func => {
            for (const event of Object.keys(this._eventsRegisterFunc)) {
                this._eventsRegisterFunc[event].delete(func);
            }
        };
        this.unregister = (func, eventNames) => {
            if (eventNames && eventNames.length) {
                eventNames.forEach(eventName => {
                    if (this._eventsRegisterFunc[eventName]) {
                        this._eventsRegisterFunc[eventName].delete(func);
                    }
                });
            }
            else {
                this._eventsRegisterFunc.onChange.delete(func);
            }
        };
        // todo dependencies
        this._events = new Set(events);
        if (!this._events.has("onChange")) {
            this._events.add("onChange");
        }
        this.dispatch = this.dispatch.bind(this);
    }
    static register(func, dispatchers) {
        const dis = dispatchers;
        for (const key in dis) {
            const val = dis[key];
            if (val && val.dispatch && val.register) {
                val.register(func);
            }
            else if (val || (val.dispatcher.dispatch && val.dispatcher.register)) {
                val.dispatcher.register(func, val.on);
            }
            else {
                throw Error("You must ot send dispatcher in resources arg");
            }
        }
    }
    static unregister(func, dispatchers) {
        const dis = dispatchers;
        for (const key in dis) {
            const val = dis[key];
            if (val && val.dispatch && val.unregister) {
                val.unregister(func);
            }
            else if (val ||
                (val.dispatcher.dispatch && val.dispatcher.unregister)) {
                val.dispatcher.unregister(func, val.on);
            }
            else {
                throw Error("You must ot send dispatcher in resources arg");
            }
        }
    }
    dispatch(eventNames) {
        if (eventNames && !(eventNames instanceof Array)) {
            throw new TypeError(`[${getTypeName(this)}::dispatch]Events must to be array, got: ${getTypeName(eventNames)}`);
        }
        let funcs_array = [...this._eventsRegisterFunc.onChange];
        if (eventNames && eventNames.length) {
            eventNames.forEach(eventName => {
                if (this._eventsRegisterFunc[eventName]) {
                    funcs_array = [
                        ...funcs_array,
                        ...this._eventsRegisterFunc[eventName]
                    ];
                }
            });
        }
        this._waited_to_update_events = new Set([
            ...(eventNames || []),
            ...this._waited_to_update_events
        ]);
        this._waited_to_update_funcs = new Set([
            ...funcs_array,
            ...this._waited_to_update_funcs
        ]);
        if (this._dispatch_count === 0) {
            //setTimeout(() => {
            try {
                const message = this._sentOnChange();
                for (const func of this._waited_to_update_funcs) {
                    func(message, this._waited_to_update_events);
                }
            }
            catch (err) {
                console.error(err);
            }
            this._waited_to_update_funcs = new Set();
            this._waited_to_update_events = new Set();
        }
    }
}
exports.Dispatcher = Dispatcher;
function getTypeName(arg) {
    if (arg && arg.constructor) {
        return arg.constructor.name;
    }
    return typeof arg;
}
